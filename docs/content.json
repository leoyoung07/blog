{"meta":{"title":"Leo Young Blog","subtitle":"Don't Repeat Yourself","description":null,"author":"Leo Young","url":"http://leoyoung07.github.io/blog"},"pages":[{"title":"","date":"2017-04-22T19:11:12.777Z","updated":"2017-02-08T05:11:00.000Z","comments":false,"path":"categories/index.html","permalink":"http://leoyoung07.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-04-22T19:11:12.777Z","updated":"2017-02-08T05:09:54.000Z","comments":false,"path":"tags/index.html","permalink":"http://leoyoung07.github.io/blog/tags/index.html","excerpt":"","text":""},{"title":"","date":"2017-04-22T19:11:12.777Z","updated":"2017-02-10T16:27:15.000Z","comments":false,"path":"friends/index.html","permalink":"http://leoyoung07.github.io/blog/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"一些好用的HTTP调试工具","slug":"http-debug-tools","date":"2017-07-30T12:19:16.000Z","updated":"2017-07-30T13:38:02.925Z","comments":true,"path":"2017/07/30/http-debug-tools/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2017/07/30/http-debug-tools/","excerpt":"","text":"一、发送请求cURLcURL 是Linux下的命令行工具，windows 下可通过MinGW安装（安装Git for windows即可）。 基本用法： GET 1curl \"http://www.hotmail.com/when/junk.cgi?birthyear=1905&amp;press=OK\" POST 12# application/x-www-form-urlencodedcurl --data \"birthyear=1905&amp;press=%20OK%20\" http://www.example.com/when.cgi HEAD 1curl --head \"http://www.hotmail.com/when/junk.cgi?birthyear=1905&amp;press=OK\" HTTPieHTTPie 是使用python开发的命令行工具，可用pip安装。 基本用法： 1http [flags] [METHOD] URL [ITEM [ITEM]] Postman/Restlet ClientPostman 和 Restlet Client都是Chrome下的扩展（应用），具有图形化界面，很容易使用。 Postman Restlet Client 二、抓包(未完待续。。。)Fiddler/CharlesWiresharkChrome dev-toolsTcpDump参考 curl - Tutorial Documentation | HTTPie – CLI HTTP client","categories":[{"name":"Tools","slug":"Tools","permalink":"http://leoyoung07.github.io/blog/categories/Tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://leoyoung07.github.io/blog/tags/tools/"}]},{"title":"关于TCP的那些琐事","slug":"tcp-notes","date":"2017-07-30T04:57:29.000Z","updated":"2017-07-30T11:08:22.625Z","comments":true,"path":"2017/07/30/tcp-notes/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2017/07/30/tcp-notes/","excerpt":"","text":"一、关于连接状态与心跳包主动断开连接如果一方主动断开连接，另一方尝试接收数据时会抛出异常，例如C#下会抛出SocketException: 123ErrorCode: 10054Message: &quot;远程主机强迫关闭了一个现有的连接。&quot;SocketErrorCode: ConnectionReset 捕获该异常，可以判断对方是否主动断开连接。 网络异常断开连接如果是网络异常导致连接断开，接收数据的一方无法得知网络连接状态，这时就需要用心跳机制来解决这个问题。TCP 本身有 Keepalive 选项，但默认关闭，而且检测周期过长（2个小时），因此一般都在应用层自己实现心跳包。心跳包即像心跳一样每隔一段时间向对方发送一个数据包，告诉对方自己连接正常。根据业务场景需要，心跳包可以两边都发送或者由一边主动发送，发送周期可设置在30s左右。如果由客户端主动发心跳包，服务端被动检测连接的周期可设置为客户端发送周期的两到三倍。 二、关于消息格式TLV格式消息格式可基于TLV（Type Length Value）进行设计： [int32_t]Type(4bytes) | [int32_t]Length(4bytes) | [bytes array]Value | 这种格式较为常见，接收方获得 Type 和 Length 后即可动态创建buffer接收、处理数据。 文本格式消息格式也可以使用类似http协议的文本格式进行设计： Header \\r\\n\\r\\n Body 文本格式便于扩展和阅读，更加灵活。这也是 UNIX编程艺术 一书中推荐的协议格式。 三、关于字节序大端序与小端序不同计算机对多字节整型的存储方式不同： Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order). 定义： 如果最低有效位在最高有效位的前面，则称小端序；反之则称大端序 不同计算机可能采用不一样的字节序（主机字节序），而网络传输一般采用大端序（网络字节序）。 主机字节序与网络字节序的转换C#中的IPAddress类提供了两个方法对主机字节序与网络字节序进行转换： 12public static int NetworkToHostOrder(int network)public static int HostToNetworkOrder(int host) 参考 TCP keepalive overview 服务端主动发送心跳包，还是客户端发送比较好？ 闲说HeartBeat心跳包和TCP协议的KeepAlive机制 大多tcp应用采用长度+数据的格式传输数据，如何防止恶意虚报长度？ IPAddress.NetworkToHostOrder Method 字节顺序-维基百科 Big and Little Endian","categories":[{"name":"TCP","slug":"TCP","permalink":"http://leoyoung07.github.io/blog/categories/TCP/"}],"tags":[{"name":"tcp","slug":"tcp","permalink":"http://leoyoung07.github.io/blog/tags/tcp/"}]},{"title":"使用TypeScript开发Node.js项目","slug":"start-a-nodejs-project-with-typescript","date":"2017-03-16T05:42:05.000Z","updated":"2017-03-16T06:23:21.000Z","comments":true,"path":"2017/03/16/start-a-nodejs-project-with-typescript/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2017/03/16/start-a-nodejs-project-with-typescript/","excerpt":"","text":"使用TypeScript开发Node.js项目的主要步骤安装TypeScript 全局安装TypeScript: npm install -g typescript 初始化node项目npm init -y 安装 @types/nodenpm install --save-dev @types/node 初始化并配置tsconfig文件 初始化tsconfig.json: tsc --init 在tsconfig.json的compilerOptions中添加typeRoots配置： 12345678&#123; \"compilerOptions\": &#123; .... \"typeRoots\": [ \"./node_modules/@types\" ] &#125;&#125; 安装依赖模块的TypeScript版本npm install --save-dev @types/xxx 参考 NodeJS QuickStart · TypeScript Deep Dive","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://leoyoung07.github.io/blog/categories/TypeScript/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://leoyoung07.github.io/blog/tags/node-js/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://leoyoung07.github.io/blog/tags/TypeScript/"}]},{"title":"ECharts 使用过程中遇到的问题","slug":"echarts-problems","date":"2017-02-20T16:00:00.000Z","updated":"2017-02-21T06:28:38.000Z","comments":true,"path":"2017/02/21/echarts-problems/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2017/02/21/echarts-problems/","excerpt":"","text":"记录ECharts使用过程中遇到的一些问题 页面内容被tooltip的div遮盖 描述： 在页面中为div元素使用全局的style（主要是宽和高）时，图表后面的内容会被tooltip的div遮盖，导致input等元素无法点击、无法输入内容。 原因： 图表初始化时会在TooltipContent方法中创建一个空的div元素作为tooltip，不带样式，而包含该div的父级div的position被设置为relative。当页面中为div元素设置全局的宽和高时，tooltip的div就会遮盖后面的元素。 解决： 修改源码，在TooltipContent方法中，tooltip的div被创建后，为其添加 display: none 样式。即： 12var el = document.createElement('div');el.style.display = \"none\"; 由于tooltip所在的div的style（主要是display属性）在显示时会动态改变，所以这样修改不会影响之后tooltip的显示。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://leoyoung07.github.io/blog/categories/JavaScript/"}],"tags":[{"name":"echarts","slug":"echarts","permalink":"http://leoyoung07.github.io/blog/tags/echarts/"}]},{"title":"JavaScript中的求模和求余","slug":"mod-and-rem-in-javascript","date":"2016-06-06T16:00:00.000Z","updated":"2017-02-08T05:31:30.000Z","comments":true,"path":"2016/06/07/mod-and-rem-in-javascript/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2016/06/07/mod-and-rem-in-javascript/","excerpt":"","text":"求模与求余求模和求余其实是两种不同的运算。当两个操作数同号时，它们的运算结果相同；而当两个操作数异号时，它们的运算结果就不同了。 求模与求余运算都分两步进行： 求整数商：c = a/b; 求值: r = a - c*b; 求模和求余的差别在第一步： 求模是向负无穷的方向舍弃小数位（(-1)/3 = -1） 求余是向0的方向舍弃小数位（(-1)/3 = 0） JavaScript中的求余JavaScript中的 % 运算符其实是求余运算，即： 1console.log((-13) % 64); 结果是-13。 JavaScript中的求模JavaScript中的求模运算可以采用以下方法实现： 1234Number.prototype.mod = function (n)&#123; return ((this % n) + n) % n;&#125; 此时，用： 1console.log((-13).mod(64)); 结果是51。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://leoyoung07.github.io/blog/categories/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://leoyoung07.github.io/blog/tags/javascript/"},{"name":"math","slug":"math","permalink":"http://leoyoung07.github.io/blog/tags/math/"}]},{"title":"关于C语言中的getch和getchar函数","slug":"c-getch-getchar","date":"2016-04-27T16:00:00.000Z","updated":"2017-02-08T05:31:16.000Z","comments":true,"path":"2016/04/28/c-getch-getchar/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2016/04/28/c-getch-getchar/","excerpt":"","text":"最近在阅读K&amp;R的经典之作The C Programming Language（C程序设计语言）时遇到了一个看似简单的函数 getchar() ，书中对其的描述是： getchar() 函数从文本流中读出下一个输入字符，并将其作为结果值返回。 并给出一段用于文件复制的代码： 12345678910#include &lt;stdio.h&gt;main()&#123; int c; while ((c = getchar()) != EOF) &#123; putchar(c); &#125;&#125; 书中说该例子就是把输入一次一个字符地复制到输出。而我在Ubuntu下和Windows下运行程序时发现每次输入完回车后，程序才会将输入的内容整行输出，即： 12abcdefabcdef 在网上查到， getchar() 是有缓冲区、有回显的，用户输入的字符（包括回车）被放在键盘缓冲区中，当用户输入回车后 getchar() 函数从缓冲区中每次读入一个字符，后续的 getchar() 不会等待用户按键，而是直接从缓冲区读取字符，直到读完缓冲区中的字符。 有人这样解释书中的描述： 在大师编写C的时候，当时并没有所谓终端输入的概念，所有的输入实际上都是按照文件进行读取的，文件中一般都是以行为单位的。因此，只有遇到换行符，那么程序会认为输入结束，然后采取执行程序的其他部分。同时，输入是按照文件的方式存取的，那么要结束一个文件的输入就需用到EOF (Enf Of File). 这也就是为什么getchar结束输入退出时要用EOF的原因。 而C语言中的 getch() 函数是无缓冲区、无回显的。同时，在Windows下（换行符为 \\r\\n ）调试的过程中发现 getchar() 和 getch() 对于换行符的处理不同： getchar() 返回的的是 \\n 而 getch() 接收到 \\r 就返回了。对此也有人这样解释： 因为getchar()是标准的C库函数，在UNIX系统里回车一律只用\\n。Windows里回车输入的其实是\\r\\n，但是C库会对其进行处理（读写文本文件时也会），统一转换为规范的\\n。而getch()则是比较低级的，会越过这个处理，貌似没有经过输入流缓冲，而是直接调用键盘服务中断获得的，就是原始按键。 另外，程序中使用 int c 而不是 char c 的原因是 EOF在函数库里一般定义为-1。因此，在这种情况下，getchar函数返回一个负值，把一个负值赋给一个char型的变量是不正确的。","categories":[{"name":"C","slug":"C","permalink":"http://leoyoung07.github.io/blog/categories/C/"}],"tags":[{"name":"c","slug":"c","permalink":"http://leoyoung07.github.io/blog/tags/c/"},{"name":"buffer","slug":"buffer","permalink":"http://leoyoung07.github.io/blog/tags/buffer/"},{"name":"LF","slug":"LF","permalink":"http://leoyoung07.github.io/blog/tags/LF/"},{"name":"windows","slug":"windows","permalink":"http://leoyoung07.github.io/blog/tags/windows/"}]},{"title":"JSONP与跨域问题","slug":"jsonp-and-cross-domain","date":"2016-03-31T16:00:00.000Z","updated":"2017-02-08T05:31:03.000Z","comments":true,"path":"2016/04/01/jsonp-and-cross-domain/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2016/04/01/jsonp-and-cross-domain/","excerpt":"","text":"跨域问题跨域问题是由于浏览器的同源策略而产生的，同源是指同协议、同域名、同端口，出于安全的考虑，浏览器禁止脚本的跨域（不同源）请求。 虽然浏览器禁止跨域请求，但是却允许引用和执行来自其他域的脚本文件，这也就是下面将要提到的 JSONP 的原理。 JSONPJSONP（JSON with Padding） 是一种动态加载js的技术，即使用javascript脚本动态加载&lt;script&gt;标签，从而使得网页可以跨域获取数据。该方法需要服务器端进行配合，动态生成javascript脚本，javascript脚本中包含网页所需的数据。 假设 www.bbbbb.com.cn 域名下有一网页需要请求 www.aaaaa.com.cn 域名下的数据，利用JSONP实现跨域请求的步骤如下： www.bbbbb.com.cn 域名下的网页中定义一个加载跨域脚本的javascript函数，即一个能够动态生成 &lt;script&gt; 标签的函数，该 &lt;script&gt; 标签的 src 指向服务器端程序（ www.aaaaa.com.cn ）所在的URL，并且URL后应附加一个 callback 参数，以便服务器端能够动态生成以 callback 为名的javascript函数： 12345678var remoteUrl = \"http://www.aaaaa.com.cn/test/jsonpTest.php?callback=\";function getDataFromRemote(callback) &#123; var remoteDataUrl = remoteUrl + callback; var script = document.createElement(\"script\"); script.setAttribute(\"src\", remoteDataUrl); document.getElementsByTagName(\"head\")[0].appendChild(script);&#125; 服务器端收到请求后，根据 callback 参数动态生成一段javascript脚本，该脚本调用 callback 函数并向其传递网页所需的数据： 1234567&lt;?phpif(isset($_GET[\"callback\"]))&#123; $json_data = json_encode([\"data\"=&gt; \"Hello World\"]); echo $_GET[\"callback\"].\"(&#123;$json_data&#125;);\";&#125;?&gt; 网页端定义名为 callback 的函数，用于接收、处理服务器端传来的数据： 12345function testCallback(jsonData) &#123; alert(jsonData[\"data\"]);&#125;getDataFromRemote('testCallback'); jQuery示例jQuery 中的 ajax 方法支持 JSONP 类型的请求，只需将 dataType 设置为 jsonp 即可，示例如下： 12345678910111213141516171819&lt;script type=\"text/javascript\" src=\"//cdn.bootcss.com/jquery/2.2.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; function getDataFromRemoteAjax() &#123; $.ajax(&#123; type: \"get\", async: true, url: \"http://www.aaaaa.com.cn/test/jsonpTest.php\", dataType: \"jsonp\", jsonpCallback: \"testCallbackAjax\", success: function (data) &#123; alert(data[\"data\"]); &#125;, error: function (err) &#123; alert(\"error\"); &#125; &#125;); &#125;&lt;/script&gt; 服务器端的代码与上例的相同。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://leoyoung07.github.io/blog/categories/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://leoyoung07.github.io/blog/tags/javascript/"},{"name":"jsonp","slug":"jsonp","permalink":"http://leoyoung07.github.io/blog/tags/jsonp/"},{"name":"cross-domain","slug":"cross-domain","permalink":"http://leoyoung07.github.io/blog/tags/cross-domain/"}]},{"title":"PHP curl post 数组与 post query字符串的区别","slug":"differences-between-post-array-and-query-string-with-php-curl","date":"2016-03-29T16:00:00.000Z","updated":"2017-02-08T10:22:19.000Z","comments":true,"path":"2016/03/30/differences-between-post-array-and-query-string-with-php-curl/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2016/03/30/differences-between-post-array-and-query-string-with-php-curl/","excerpt":"","text":"使用PHP的curl方法post数据时通常使用以下方法： 123456789$post_fields = [\"aaa\"=&gt;\"aaaa\", \"bbb\"=&gt;\"bbbb\"];$url = \"http://localhost/sandbox/PHPTest/output.php\";$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt($ch, CURLOPT_POST, 1);curl_setopt($ch, CURLOPT_POSTFIELDS, $post_fields);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$response = curl_exec($ch);echo $response; $url为php页面时，该方法没有遇到问题，但$url为jsp页面时，出现post数据为空的情况，即在jsp页面用request.getParameter(&quot;aaa&quot;)得到的结果为null。尝试将$post_fields拼接为query字符串： 1$post_fields = http_build_query($post_fields); 结果正确。抓包对比直接post数组与post query字符串两种方法结果如下： 直接post数组 header body post query字符串 header body 可见，直接post数组时，Content-type为multipart/form-data；而post query字符串时Content-type为application/x-www-form-urlencoded。 PHP手册中对CURLOPT_POSTFIELDS的说明如下： 全部数据使用HTTP协议中的”POST”操作来发送。要发送文件，在文件名前面加上@前缀并使用完整路径。这个参数可以通过urlencoded后的字符串类似’para1=val1&amp;para2=val2&amp;…’或使用一个以字段名为键值，字段数据为值的数组。如果value是一个数组，Content-Type头将会被设置成multipart/form-data。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://leoyoung07.github.io/blog/categories/PHP/"}],"tags":[{"name":"php","slug":"php","permalink":"http://leoyoung07.github.io/blog/tags/php/"},{"name":"curl","slug":"curl","permalink":"http://leoyoung07.github.io/blog/tags/curl/"},{"name":"post","slug":"post","permalink":"http://leoyoung07.github.io/blog/tags/post/"}]},{"title":"在windows环境下用GitStack搭建git server的方法","slug":"git-stack-on-windows","date":"2016-03-27T16:00:00.000Z","updated":"2017-07-30T04:41:39.707Z","comments":true,"path":"2016/03/28/git-stack-on-windows/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2016/03/28/git-stack-on-windows/","excerpt":"","text":"在Windows环境下用GitStack搭建git server的方法： 安装/配置GitStack GitStack下载地址：GitStack 在服务器下载安装GitStack，安装完成后，可在 Admin 页面的 Setting 中配置 Server Ports 和 Repositories Location ，然后在 Security 中选择 Communication protocols 为 Accept http and https 。 添加User 在 Admin 页面的 Users &amp; Groups 中添加User。 添加Repository 在 Admin 页面的 Repository 中新建Repository，并添加刚才创建的User。 远程clone 在自己的机器上clone刚才添加的Repository： git clone https://name:password@your_server_domain:port/your_repository.git 远程push 在自己的机器上添加文件，并push到服务器： 123git add --all .git commit -m \"init\"git push origin master 服务器本地clone 服务器上，在你想要部署代码的位置进行clone： git clone https://name:password@localhost:port/your_repository.git 配置Hook 服务器上，找到你Repository所在位置，打开hooks文件夹添加名为 post-receive 的文件，文件内容例如： 123456#!/bin/shunset GIT_DIRDeployPath=path_to_your_deploy_foldercd $DeployPathgit pull origin master 修改GitStack服务的登录方式 在服务中找到 GitStack ，右键 属性 打开登录选项卡，将登录身份由 本地系统账户 改为 Administrator ，重启 GitStack 服务。 完成以上的步骤，下次从自己的机器push到服务器时，就可以实现自动部署。","categories":[{"name":"Git","slug":"Git","permalink":"http://leoyoung07.github.io/blog/categories/Git/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://leoyoung07.github.io/blog/tags/windows/"},{"name":"git","slug":"git","permalink":"http://leoyoung07.github.io/blog/tags/git/"},{"name":"server","slug":"server","permalink":"http://leoyoung07.github.io/blog/tags/server/"}]},{"title":"用JavaScript获取URL参数的方法","slug":"javascript-get-url-search-params","date":"2016-03-26T16:00:00.000Z","updated":"2017-02-08T05:30:13.000Z","comments":true,"path":"2016/03/27/javascript-get-url-search-params/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2016/03/27/javascript-get-url-search-params/","excerpt":"","text":"JavaScript中通过正则表达式获取URL参数的方法： 1234567function getQueryString(name) &#123; var reg = new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\", \"i\"); var r = location.search.substr(1).match(reg); if (r != null) return decodeURI(r[2]); return null;&#125; r[2]是分组2的内容，即([^&amp;]*)所匹配的内容（r[0]是整个正则表达式所匹配的内容） 正则表达式后边的“i”表示忽略大小写","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://leoyoung07.github.io/blog/categories/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://leoyoung07.github.io/blog/tags/javascript/"},{"name":"regex","slug":"regex","permalink":"http://leoyoung07.github.io/blog/tags/regex/"}]},{"title":"微信公众平台下通过网页授权获取用户信息的方法","slug":"wechat-auth-get-user-info","date":"2016-03-21T16:00:00.000Z","updated":"2017-02-08T05:29:46.000Z","comments":true,"path":"2016/03/22/wechat-auth-get-user-info/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2016/03/22/wechat-auth-get-user-info/","excerpt":"","text":"授权方式微信网页的授权方式分为两种： 以 snsapi_base 为 scope 发起的网页授权：用于获取用户的 openid ，为静默授权 以 snsapi_userinfo 为 scope 发起的网页授权：用于获取用户的基本信息，需要用户手动同意授权 下面以 snsapi_userinfo 的类型为例，说明网页授权的步骤： 获取code引导关注者打开以下页面： https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=STATE#wechat_redirect 其中 redirect_uri 为需要获取用户信息的页面，redirect_uri 需要进行 urlencode 处理。用户同意授权之后，redirect_uri 的页面就可以通过 GET 的方式从 url 中拿到 code，即： $code = $_GET[&quot;code&quot;]; 用code换取网页授权的access_token利用上一步获取的code即可换取网页授权access_token，方法如下： 12345678$api_url = \"https://api.weixin.qq.com/sns/oauth2/access_token?appid=&#123;$appid&#125;&amp;secret=&#123;$secret&#125;&amp;code=&#123;$code&#125;&amp;grant_type=authorization_code\";$response_info = self::get_info_from_api($api_url);if(isset($response_info[\"errcode\"]))&#123; exit(\"get access token failed: \".$response_info[\"errcode\"].\", \".$response_info[\"errmsg\"]);&#125;$access_token = $response_info[\"access_token\"]; 其中，get_info_from_api 的定义如下： 123456789101112public static function get_info_from_api($api_url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $api_url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); $result = curl_exec($ch); curl_close($ch); $response_info = json_decode($result, true); return $response_info;&#125; get_info_from_api 是利用PHP中的curl函数以 GET 方法从微信提供的 api 获取数据，返回的结果为关联数组的形式。 获取用户信息接下来，即可用 access_token 获取用户信息： 1234567$open_id = $response_info[\"openid\"];$api_url = \"https://api.weixin.qq.com/sns/userinfo?access_token=&#123;$access_token&#125;&amp;openid=&#123;$open_id&#125;&amp;lang=zh_CN\";$user_info = self::get_info_from_api($api_url);if(isset($user_info[\"errcode\"]))&#123; exit(\"get user info failed: \".$user_info[\"errcode\"].\", \".$user_info[\"errmsg\"]);&#125;","categories":[{"name":"WeChat","slug":"WeChat","permalink":"http://leoyoung07.github.io/blog/categories/WeChat/"}],"tags":[{"name":"php","slug":"php","permalink":"http://leoyoung07.github.io/blog/tags/php/"},{"name":"wechat","slug":"wechat","permalink":"http://leoyoung07.github.io/blog/tags/wechat/"}]},{"title":"将数字转换为EXCEL列名的方法","slug":"number-to-excel-letter","date":"2015-12-25T16:00:00.000Z","updated":"2017-02-08T05:39:50.000Z","comments":true,"path":"2015/12/26/number-to-excel-letter/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2015/12/26/number-to-excel-letter/","excerpt":"","text":"用递归函数将数字转换为EXCEL中的列名，直接上代码（PHP）： 12345678910111213141516171819202122232425//递归求解function R_NumToLetter($num)&#123; if($num == 0) &#123; return ''; &#125; $base = 26; $mod = (int)($num % $base); $num = (int)($num / $base); if($mod == 0) return R_NumToLetter($num - 1).NumToLetter($base); if($num == 0) return NumToLetter($mod); return R_NumToLetter($num).NumToLetter($mod);&#125;function NumToLetter($num)&#123; if($num == 0) return ''; $num = (int)$num - 1; $ord_A = ord('A'); $chr = chr($ord_A + $num); return $chr;&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"http://leoyoung07.github.io/blog/categories/PHP/"}],"tags":[{"name":"php","slug":"php","permalink":"http://leoyoung07.github.io/blog/tags/php/"},{"name":"convert","slug":"convert","permalink":"http://leoyoung07.github.io/blog/tags/convert/"}]},{"title":"微信公众平台自定义菜单配置工具的实现","slug":"wechat-button-manage","date":"2015-12-08T16:00:00.000Z","updated":"2017-02-08T05:28:56.000Z","comments":true,"path":"2015/12/09/wechat-button-manage/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2015/12/09/wechat-button-manage/","excerpt":"","text":"由于JS脚本跨域访问的问题，无法通过jQuery的Ajax方法直接调用微信的API，故采用服务器端转发的方式与微信API交互。 配置自定义菜单须先获取Access Token，前端JS代码如下： 12345678910111213141516171819202122232425function getAccessToken()&#123; var appidParam = $(\"#appid\").val(); var secretParam = $(\"#secret\").val(); var date = new Date(); var url = \"get_access_token.php?appid=\"+appidParam+\"&amp;secret=\"+secretParam+\"&amp;time=\"+date.getTime(); $.get(url, function (data,status) &#123; var result = eval(\"(\"+data+\")\"); $(\"#info\").css(\"display\",\"block\"); if(typeof (result[\"errcode\"])!=\"undefined\") &#123; var errorInfo = \"错误代码：\"+result[\"errcode\"]+\";错误信息：\"+result[\"errmsg\"]; $(\"#info\").html(errorInfo); $(\"#changeBtn\").attr(\"disabled\",\"disabled\"); &#125; else &#123; var successInfo = \"获取Access Token 成功：\" + result[\"access_token\"]; $(\"#accessToken\").val(result[\"access_token\"]); $(\"#info\").html(successInfo); $(\"#changeBtn\").removeAttr(\"disabled\"); &#125; &#125;)&#125; 服务器端使用PHP的curl工具进行转发，代码如下 1234567891011$appid = $_GET[\"appid\"];$secret = $_GET[\"secret\"];$api_url = \"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&#123;$appid&#125;&amp;secret=&#123;$secret&#125;\";$ch = curl_init();curl_setopt($ch,CURLOPT_URL,$api_url);curl_setopt($ch,CURLOPT_RETURNTRANSFER,1);curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);$json_result = curl_exec($ch);curl_close($ch);echo $json_result; 利用获取到的 Access Token，下一步可以配置自定义菜单。目前还需要自己编写自定义菜单的JSON，以后有时间会加上可视化界面。通过POST方法向服务器提交JSON的JS代码如下： 12345678910111213141516function changeButton()&#123; var url = \"button_manage.php?access_token=\"+$(\"#accessToken\").val(); var button_json = $(\"#buttonBody\").val(); $.post(url,&#123;\"button_json\":button_json&#125;, function (data,status) &#123; var result = eval(\"(\"+data+\")\"); if(result[\"errcode\"] == 0) &#123; alert(\"配置成功\"); &#125; else &#123; alert(\"配置失败，错误代码：\"+result[\"errcode\"]+\"错误信息：\"+result[\"errmsg\"]); &#125; &#125;)&#125; 服务器端的PHP代码如下： 12345678910111213$access_token = $_GET[\"access_token\"];$api_url = \"https://api.weixin.qq.com/cgi-bin/menu/create?access_token=&#123;$access_token&#125;\";$button_json = $_POST[\"button_json\"];$ch = curl_init();curl_setopt($ch,CURLOPT_URL,$api_url);curl_setopt($ch,CURLOPT_RETURNTRANSFER,1);curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);curl_setopt($ch, CURLOPT_POST, 1);curl_setopt($ch, CURLOPT_POSTFIELDS, $button_json);$json_result = curl_exec($ch);curl_close($ch);echo $json_result; 实现效果可访问： http://leo07.sinaapp.com/button_manage.html","categories":[{"name":"WeChat","slug":"WeChat","permalink":"http://leoyoung07.github.io/blog/categories/WeChat/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://leoyoung07.github.io/blog/tags/tools/"},{"name":"php","slug":"php","permalink":"http://leoyoung07.github.io/blog/tags/php/"},{"name":"curl","slug":"curl","permalink":"http://leoyoung07.github.io/blog/tags/curl/"},{"name":"wechat","slug":"wechat","permalink":"http://leoyoung07.github.io/blog/tags/wechat/"}]},{"title":"微信公众平台带参数二维码配置工具的实现","slug":"wechat-qr-code-manage","date":"2015-12-08T16:00:00.000Z","updated":"2017-02-08T05:29:20.000Z","comments":true,"path":"2015/12/09/wechat-qr-code-manage/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2015/12/09/wechat-qr-code-manage/","excerpt":"","text":"配置带参数的二维码同样需要先获取Access Token，获取方法在 微信公众平台自定义菜单配置工具的实现 一文中有描述。 利用获取到的Access Token，可以创建二维码的Ticket。通过POST方法向服务器提交相关信息，JS代码如下： 123456789101112131415161718192021222324252627282930function getTicket()&#123; var url = \"qrcode_manage.php?access_token=\"+$(\"#accessToken\").val(); var qrcode_type = $(\"#qrType\").val(); var qrcode_scene_id = $(\"#qrSceneId\").val(); $.post(url, &#123; \"qrcode_type\":qrcode_type, \"qrcode_scene_id\":qrcode_scene_id &#125;, function (data,status) &#123; var result = eval(\"(\"+data+\")\"); $(\"#ticketInfo\").css(\"display\",\"block\"); if(typeof (result[\"errcode\"])!=\"undefined\") &#123; var errorInfo = \"错误代码：\"+result[\"errcode\"]+\";错误信息：\"+result[\"errmsg\"]; $(\"#ticketInfo\").html(errorInfo); $(\"#getQrcodeBtn\").attr(\"disabled\",\"disabled\"); &#125; else &#123; var successInfo = \"获取Ticket 成功，Ticket：\" + result[\"ticket\"]; successInfo += \"&lt;br&gt;url:\" + result[\"url\"]; $(\"#ticket\").val(result[\"ticket\"]); $(\"#ticketInfo\").html(successInfo); $(\"#getQrcodeBtn\").removeAttr(\"disabled\"); &#125; &#125; );&#125; 服务器端进行转发的PHP代码如下： 123456789101112131415161718192021222324252627$access_token = $_GET[\"access_token\"];$api_url = \"https://api.weixin.qq.com/cgi-bin/qrcode/create?access_token=&#123;$access_token&#125;\";$qrcode_type = $_POST[\"qrcode_type\"];$qrcode_scene_id = (int)$_POST[\"qrcode_scene_id\"];$qrcode_array = array();if($qrcode_type == \"QR_SCENE\")&#123; $qrcode_array[\"expire_seconds\"] = 604800; //七天 $qrcode_array[\"action_name\"] = \"QR_SCENE\";&#125;else&#123; $qrcode_array[\"action_name\"] = \"QR_LIMIT_SCENE\";&#125;$qrcode_array[\"action_info\"][\"scene\"][\"scene_id\"] = $qrcode_scene_id;$qrcode_json = json_encode($qrcode_array);$ch = curl_init();curl_setopt($ch,CURLOPT_URL,$api_url);curl_setopt($ch,CURLOPT_RETURNTRANSFER,1);curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);curl_setopt($ch, CURLOPT_POST, 1);curl_setopt($ch, CURLOPT_POSTFIELDS, $qrcode_json);$json_result = curl_exec($ch);curl_close($ch);echo $json_result; 之后，可以通过Ticket换取二维码，JS代码如下： 1234567function getQrcode()&#123; var ticket = $(\"#ticket\").val(); var date = new Date(); var url = \"qrcode_manage.php?ticket=\"+ticket+\"&amp;time=\"+date.getTime(); $(\"#qrcode\").attr(\"src\",\"qrcode_manage.php?ticket=\"+ticket+\"&amp;time=\"+date.getTime());&#125; 服务器端进行转发的PHP代码如下： 12345678910$ticket = $_GET[\"ticket\"];$api_url = \"https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=&#123;$ticket&#125;\";$ch = curl_init();curl_setopt($ch,CURLOPT_URL,$api_url);curl_setopt($ch,CURLOPT_RETURNTRANSFER,1);curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);$qrcode_result = curl_exec($ch);curl_close($ch);echo $qrcode_result; 实现效果可访问： http://leo07.sinaapp.com/qrcode_manage.html","categories":[{"name":"WeChat","slug":"WeChat","permalink":"http://leoyoung07.github.io/blog/categories/WeChat/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://leoyoung07.github.io/blog/tags/tools/"},{"name":"php","slug":"php","permalink":"http://leoyoung07.github.io/blog/tags/php/"},{"name":"curl","slug":"curl","permalink":"http://leoyoung07.github.io/blog/tags/curl/"},{"name":"wechat","slug":"wechat","permalink":"http://leoyoung07.github.io/blog/tags/wechat/"}]}]}