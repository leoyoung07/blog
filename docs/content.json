{"meta":{"title":"Leo Young Blog","subtitle":"Don't Repeat Yourself","description":null,"author":"Leo Young","url":"http://leoyoung07.github.io/blog"},"pages":[{"title":"","date":"2017-02-08T05:11:00.114Z","updated":"2017-02-08T05:11:00.000Z","comments":false,"path":"categories/index.html","permalink":"http://leoyoung07.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-02-08T05:09:54.304Z","updated":"2017-02-08T05:09:54.304Z","comments":false,"path":"tags/index.html","permalink":"http://leoyoung07.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"局域网环境下的“云”剪贴板","slug":"cloud-clipboard-based-on-lan","date":"2016-12-03T16:00:00.000Z","updated":"2017-02-08T05:32:42.297Z","comments":true,"path":"2016/12/04/cloud-clipboard-based-on-lan/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2016/12/04/cloud-clipboard-based-on-lan/","excerpt":"","text":"","categories":[{"name":"L-Clipboard","slug":"L-Clipboard","permalink":"http://leoyoung07.github.io/blog/categories/L-Clipboard/"}],"tags":[{"name":"c#","slug":"c","permalink":"http://leoyoung07.github.io/blog/tags/c/"},{"name":"tcp","slug":"tcp","permalink":"http://leoyoung07.github.io/blog/tags/tcp/"},{"name":"udp","slug":"udp","permalink":"http://leoyoung07.github.io/blog/tags/udp/"}]},{"title":"Nginx多站点配置","slug":"nginx-multi-site","date":"2016-11-20T16:00:00.000Z","updated":"2017-02-08T05:32:30.081Z","comments":true,"path":"2016/11/21/nginx-multi-site/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2016/11/21/nginx-multi-site/","excerpt":"","text":"概述利用Nginx可以在一台服务器上搭建多个站点，实现从不同的二级域名访问不同的web应用。例如，我有一级域名 leoyoung.site，其下有2个二级域名 test.leoyoung.site 和 blog.leoyoung.site，它们都解析至同一IP，通过配置Nginx可以实现将 test.leoyoung.site 指向一个PHP站点，将 blog.leoyoung.site 指向一个 Django站点。服务器运行ubuntu 14.04系统，以下是配置方法。 安装Nginxsudo apt-get install nginx 安装后，所有的配置文件都在/etc/nginx下， 程序文件为/usr/sbin/nginx。查看nginx.conf文件，注意到以下几行配置： 123456### Virtual Host Configs##include /etc/nginx/conf.d/*.conf;include /etc/nginx/sites-enabled/*; 因此，可在/etc/nginx/conf.d/目录下添加conf文件以实现多站点配置。 Nginx下的PHP站点配置 安装PHP环境 sudo apt-get install php5-cli php5-cgi mysql-server php5-mysql 安装FastCgi sudo apt-get install php5-fpm 配置Nginx 在 /etc/nginx/conf.d 目录下创建test.leoyoung.site.conf配置文件，其内容为： 123456789101112131415161718192021222324252627server &#123; listen 80; root /data/htdoc/test; index index.html index.htm; server_name test.leoyoung.site; location / &#123; # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; # Uncomment to enable naxsi on this location # include /etc/nginx/naxsi.rules &#125; location ~ \\.php$ &#123; fastcgi_split_path_info ^(.+\\.php)(/.+)$; # NOTE: You should have \"cgi.fix_pathinfo = 0;\" in php.ini # With php5-cgi alone: fastcgi_pass 127.0.0.1:8000; # With php5-fpm: #fastcgi_pass unix:/var/run/php5-fpm.sock; fastcgi_index index.php; include fastcgi_params; &#125;&#125; /data/htdoc/test 为PHP站点的根目录。 设置php-cgi开机启动 在 中添加一行： spawn-fcgi -a 127.0.0.1 -p 8000 -C 10 -u www-data -f /usr/bin/php-cgi &gt;&gt; /data/log/phpcgi.log 2&gt;&amp;1 &amp; 其中， /data/log/phpcgi.log 为访问日志文件。 Nginx下的Django站点配置 安装Django pip3 install Django 安装uwsgi pip3 install uwsgi 配置uwsgi 配置Nginx 处理静态文件 参考 Nginx - Ubuntu中文 Ubuntu上通过nginx部署Django笔记","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://leoyoung07.github.io/blog/categories/Nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://leoyoung07.github.io/blog/tags/nginx/"}]},{"title":"MVVM Light 应用开发（一）——入门","slug":"mvvm-light-dev-1","date":"2016-09-09T16:00:00.000Z","updated":"2017-02-08T05:32:16.323Z","comments":true,"path":"2016/09/10/mvvm-light-dev-1/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2016/09/10/mvvm-light-dev-1/","excerpt":"","text":"MVVM 简介MVVM Light 简介安装模版 &amp; 创建应用Hello World","categories":[{"name":"MVVM-Light-Dev","slug":"MVVM-Light-Dev","permalink":"http://leoyoung07.github.io/blog/categories/MVVM-Light-Dev/"}],"tags":[{"name":"c#","slug":"c","permalink":"http://leoyoung07.github.io/blog/tags/c/"},{"name":"mvvm","slug":"mvvm","permalink":"http://leoyoung07.github.io/blog/tags/mvvm/"},{"name":"wpf","slug":"wpf","permalink":"http://leoyoung07.github.io/blog/tags/wpf/"}]},{"title":"用C语言开发PHP扩展（一）——入门与填坑","slug":"dev-php-extension-in-c-1","date":"2016-08-29T16:00:00.000Z","updated":"2017-02-08T05:31:43.968Z","comments":true,"path":"2016/08/30/dev-php-extension-in-c-1/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2016/08/30/dev-php-extension-in-c-1/","excerpt":"","text":"开发环境 PHP源码 函数定义 扩展骨架 开发步骤 To use your new extension, you will have to execute the following steps: $ cd .. $ vi ext/myfunctions/config.m4 $ ./buildconf $ ./configure –[with|enable]-myfunctions $ make $ ./php -f ext/myfunctions/myfunctions.php $ vi ext/myfunctions/myfunctions.c $ make Repeat steps 3-6 until you are satisfied with ext/myfunctions/config.m4 andstep 6 confirms that your module is compiled into PHP. Then, start writingcode and repeat the last two steps as often as necessary. 函数实现 编译 测试运行 跨平台CRLF与LF bison安装checking for bison version… invalidconfigure: WARNING: This bison version is not supported for regeneration of the Zend/PHP parsers (found: none, min: 204, excluded: ).checking for re2c… noconfigure: WARNING: You will need re2c 0.13.4 or later if you want to regenerate PHP parsers.configure: error: bison is required to build PHP/Zend when building a GIT checkout! libxml2configure: error: xml2-config not found. Please check your libxml2 installation.解决apt-get install libxml2-dev ./sapi/cli/php https://www.hongweipeng.com/index.php/archives/739/","categories":[{"name":"PHP-Extension-Dev","slug":"PHP-Extension-Dev","permalink":"http://leoyoung07.github.io/blog/categories/PHP-Extension-Dev/"}],"tags":[{"name":"c","slug":"c","permalink":"http://leoyoung07.github.io/blog/tags/c/"},{"name":"php","slug":"php","permalink":"http://leoyoung07.github.io/blog/tags/php/"}]},{"title":"用C语言开发PHP扩展（二）——封装C函数的扩展","slug":"dev-php-extension-in-c-2","date":"2016-08-29T16:00:00.000Z","updated":"2017-02-08T05:31:58.771Z","comments":true,"path":"2016/08/30/dev-php-extension-in-c-2/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2016/08/30/dev-php-extension-in-c-2/","excerpt":"","text":"函数定义之间不能有空行 使用资源是为了实现自动释放","categories":[{"name":"PHP-Extension-Dev","slug":"PHP-Extension-Dev","permalink":"http://leoyoung07.github.io/blog/categories/PHP-Extension-Dev/"}],"tags":[{"name":"c","slug":"c","permalink":"http://leoyoung07.github.io/blog/tags/c/"},{"name":"php","slug":"php","permalink":"http://leoyoung07.github.io/blog/tags/php/"}]},{"title":"JavaScript中的求模和求余","slug":"mod-and-rem-in-javascript","date":"2016-06-06T16:00:00.000Z","updated":"2017-02-08T05:31:30.083Z","comments":true,"path":"2016/06/07/mod-and-rem-in-javascript/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2016/06/07/mod-and-rem-in-javascript/","excerpt":"","text":"求模与求余求模和求余其实是两种不同的运算。当两个操作数同号时，它们的运算结果相同；而当两个操作数异号时，它们的运算结果就不同了。 求模与求余运算都分两步进行： 求整数商：c = a/b; 求值: r = a - c*b; 求模和求余的差别在第一步： 求模是向负无穷的方向舍弃小数位（(-1)/3 = -1） 求余是向0的方向舍弃小数位（(-1)/3 = 0） JavaScript中的求余JavaScript中的 % 运算符其实是求余运算，即： 1console.log((-13) % 64); 结果是-13。 JavaScript中的求模JavaScript中的求模运算可以采用以下方法实现： 1234Number.prototype.mod = function (n)&#123; return ((this % n) + n) % n;&#125; 此时，用： 1console.log((-13).mod(64)); 结果是51。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://leoyoung07.github.io/blog/categories/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://leoyoung07.github.io/blog/tags/javascript/"},{"name":"math","slug":"math","permalink":"http://leoyoung07.github.io/blog/tags/math/"}]},{"title":"关于C语言中的getch和getchar函数","slug":"c-getch-getchar","date":"2016-04-27T16:00:00.000Z","updated":"2017-02-08T05:31:16.424Z","comments":true,"path":"2016/04/28/c-getch-getchar/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2016/04/28/c-getch-getchar/","excerpt":"","text":"最近在阅读K&amp;R的经典之作The C Programming Language（C程序设计语言）时遇到了一个看似简单的函数 getchar() ，书中对其的描述是： getchar() 函数从文本流中读出下一个输入字符，并将其作为结果值返回。 并给出一段用于文件复制的代码： 12345678910#include &lt;stdio.h&gt;main()&#123; int c; while ((c = getchar()) != EOF) &#123; putchar(c); &#125;&#125; 书中说该例子就是把输入一次一个字符地复制到输出。而我在Ubuntu下和Windows下运行程序时发现每次输入完回车后，程序才会将输入的内容整行输出，即： 12abcdefabcdef 在网上查到， getchar() 是有缓冲区、有回显的，用户输入的字符（包括回车）被放在键盘缓冲区中，当用户输入回车后 getchar() 函数从缓冲区中每次读入一个字符，后续的 getchar() 不会等待用户按键，而是直接从缓冲区读取字符，直到读完缓冲区中的字符。 有人这样解释书中的描述： 在大师编写C的时候，当时并没有所谓终端输入的概念，所有的输入实际上都是按照文件进行读取的，文件中一般都是以行为单位的。因此，只有遇到换行符，那么程序会认为输入结束，然后采取执行程序的其他部分。同时，输入是按照文件的方式存取的，那么要结束一个文件的输入就需用到EOF (Enf Of File). 这也就是为什么getchar结束输入退出时要用EOF的原因。 而C语言中的 getch() 函数是无缓冲区、无回显的。同时，在Windows下（换行符为 \\r\\n ）调试的过程中发现 getchar() 和 getch() 对于换行符的处理不同： getchar() 返回的的是 \\n 而 getch() 接收到 \\r 就返回了。对此也有人这样解释： 因为getchar()是标准的C库函数，在UNIX系统里回车一律只用\\n。Windows里回车输入的其实是\\r\\n，但是C库会对其进行处理（读写文本文件时也会），统一转换为规范的\\n。而getch()则是比较低级的，会越过这个处理，貌似没有经过输入流缓冲，而是直接调用键盘服务中断获得的，就是原始按键。 另外，程序中使用 int c 而不是 char c 的原因是 EOF在函数库里一般定义为-1。因此，在这种情况下，getchar函数返回一个负值，把一个负值赋给一个char型的变量是不正确的。","categories":[{"name":"C","slug":"C","permalink":"http://leoyoung07.github.io/blog/categories/C/"}],"tags":[{"name":"c","slug":"c","permalink":"http://leoyoung07.github.io/blog/tags/c/"},{"name":"buffer","slug":"buffer","permalink":"http://leoyoung07.github.io/blog/tags/buffer/"},{"name":"LF","slug":"LF","permalink":"http://leoyoung07.github.io/blog/tags/LF/"},{"name":"windows","slug":"windows","permalink":"http://leoyoung07.github.io/blog/tags/windows/"}]},{"title":"JSONP与跨域问题","slug":"jsonp-and-cross-domain","date":"2016-03-31T16:00:00.000Z","updated":"2017-02-08T05:31:03.393Z","comments":true,"path":"2016/04/01/jsonp-and-cross-domain/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2016/04/01/jsonp-and-cross-domain/","excerpt":"","text":"跨域问题跨域问题是由于浏览器的同源策略而产生的，同源是指同协议、同域名、同端口，出于安全的考虑，浏览器禁止脚本的跨域（不同源）请求。 虽然浏览器禁止跨域请求，但是却允许引用和执行来自其他域的脚本文件，这也就是下面将要提到的 JSONP 的原理。 JSONPJSONP（JSON with Padding） 是一种动态加载js的技术，即使用javascript脚本动态加载&lt;script&gt;标签，从而使得网页可以跨域获取数据。该方法需要服务器端进行配合，动态生成javascript脚本，javascript脚本中包含网页所需的数据。 假设 www.bbbbb.com.cn 域名下有一网页需要请求 www.aaaaa.com.cn 域名下的数据，利用JSONP实现跨域请求的步骤如下： www.bbbbb.com.cn 域名下的网页中定义一个加载跨域脚本的javascript函数，即一个能够动态生成 &lt;script&gt; 标签的函数，该 &lt;script&gt; 标签的 src 指向服务器端程序（ www.aaaaa.com.cn ）所在的URL，并且URL后应附加一个 callback 参数，以便服务器端能够动态生成以 callback 为名的javascript函数： 12345678var remoteUrl = \"http://www.aaaaa.com.cn/test/jsonpTest.php?callback=\";function getDataFromRemote(callback) &#123; var remoteDataUrl = remoteUrl + callback; var script = document.createElement(\"script\"); script.setAttribute(\"src\", remoteDataUrl); document.getElementsByTagName(\"head\")[0].appendChild(script);&#125; 服务器端收到请求后，根据 callback 参数动态生成一段javascript脚本，该脚本调用 callback 函数并向其传递网页所需的数据： 1234567&lt;?phpif(isset($_GET[\"callback\"]))&#123; $json_data = json_encode([\"data\"=&gt; \"Hello World\"]); echo $_GET[\"callback\"].\"(&#123;$json_data&#125;);\";&#125;?&gt; 网页端定义名为 callback 的函数，用于接收、处理服务器端传来的数据： 12345function testCallback(jsonData) &#123; alert(jsonData[\"data\"]);&#125;getDataFromRemote('testCallback'); jQuery示例jQuery 中的 ajax 方法支持 JSONP 类型的请求，只需将 dataType 设置为 jsonp 即可，示例如下： 12345678910111213141516171819&lt;script type=\"text/javascript\" src=\"//cdn.bootcss.com/jquery/2.2.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; function getDataFromRemoteAjax() &#123; $.ajax(&#123; type: \"get\", async: true, url: \"http://www.aaaaa.com.cn/test/jsonpTest.php\", dataType: \"jsonp\", jsonpCallback: \"testCallbackAjax\", success: function (data) &#123; alert(data[\"data\"]); &#125;, error: function (err) &#123; alert(\"error\"); &#125; &#125;); &#125;&lt;/script&gt; 服务器端的代码与上例的相同。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://leoyoung07.github.io/blog/categories/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://leoyoung07.github.io/blog/tags/javascript/"},{"name":"jsonp","slug":"jsonp","permalink":"http://leoyoung07.github.io/blog/tags/jsonp/"},{"name":"cross-domain","slug":"cross-domain","permalink":"http://leoyoung07.github.io/blog/tags/cross-domain/"}]},{"title":"PHP curl post 数组与 post query字符串的区别","slug":"differences-between-post-array-and-query-string-with-php-curl","date":"2016-03-29T16:00:00.000Z","updated":"2017-02-08T10:22:19.767Z","comments":true,"path":"2016/03/30/differences-between-post-array-and-query-string-with-php-curl/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2016/03/30/differences-between-post-array-and-query-string-with-php-curl/","excerpt":"","text":"使用PHP的curl方法post数据时通常使用以下方法： 123456789$post_fields = [\"aaa\"=&gt;\"aaaa\", \"bbb\"=&gt;\"bbbb\"];$url = \"http://localhost/sandbox/PHPTest/output.php\";$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt($ch, CURLOPT_POST, 1);curl_setopt($ch, CURLOPT_POSTFIELDS, $post_fields);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$response = curl_exec($ch);echo $response; $url为php页面时，该方法没有遇到问题，但$url为jsp页面时，出现post数据为空的情况，即在jsp页面用request.getParameter(&quot;aaa&quot;)得到的结果为null。尝试将$post_fields拼接为query字符串： 1$post_fields = http_build_query($post_fields); 结果正确。抓包对比直接post数组与post query字符串两种方法结果如下： 直接post数组 header body post query字符串 header body 可见，直接post数组时，Content-type为multipart/form-data；而post query字符串时Content-type为application/x-www-form-urlencoded。 PHP手册中对CURLOPT_POSTFIELDS的说明如下： 全部数据使用HTTP协议中的”POST”操作来发送。要发送文件，在文件名前面加上@前缀并使用完整路径。这个参数可以通过urlencoded后的字符串类似’para1=val1&amp;para2=val2&amp;…’或使用一个以字段名为键值，字段数据为值的数组。如果value是一个数组，Content-Type头将会被设置成multipart/form-data。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://leoyoung07.github.io/blog/categories/PHP/"}],"tags":[{"name":"php","slug":"php","permalink":"http://leoyoung07.github.io/blog/tags/php/"},{"name":"curl","slug":"curl","permalink":"http://leoyoung07.github.io/blog/tags/curl/"},{"name":"post","slug":"post","permalink":"http://leoyoung07.github.io/blog/tags/post/"}]},{"title":"在windows环境下用GitStack搭建git server的方法","slug":"git-server-on-windows","date":"2016-03-27T16:00:00.000Z","updated":"2017-02-08T05:30:32.071Z","comments":true,"path":"2016/03/28/git-server-on-windows/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2016/03/28/git-server-on-windows/","excerpt":"","text":"在Windows环境下用GitStack搭建git server的方法： 安装/配置GitStack GitStack下载地址：GitStack 在服务器下载安装GitStack，安装完成后，可在 Admin 页面的 Setting 中配置 Server Ports 和 Repositories Location ，然后在 Security 中选择 Communication protocols 为 Accept http and https 。 添加User 在 Admin 页面的 Users &amp; Groups 中添加User。 添加Repository 在 Admin 页面的 Repository 中新建Repository，并添加刚才创建的User。 远程clone 在自己的机器上clone刚才添加的Repository： git clone https://name:password@your_server_domain:port/your_repository.git 远程push 在自己的机器上添加文件，并push到服务器： 123git add --all .git commit -m \"init\"git push origin master 服务器本地clone 服务器上，在你想要部署代码的位置进行clone： git clone https://name:password@localhost:port/your_repository.git 配置Hook 服务器上，找到你Repository所在位置，打开hooks文件夹添加名为 post-receive 的文件，文件内容例如： 123456#!/bin/shunset GIT_DIRDeployPath=path_to_your_deploy_foldercd $DeployPathgit pull origin master 修改GitStack服务的登录方式 在服务中找到 GitStack ，右键 属性 打开登录选项卡，将登录身份由 本地系统账户 改为 Administrator ，重启 GitStack 服务。 完成以上的步骤，下次从自己的机器push到服务器时，就可以实现自动部署。","categories":[{"name":"Git","slug":"Git","permalink":"http://leoyoung07.github.io/blog/categories/Git/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://leoyoung07.github.io/blog/tags/windows/"},{"name":"git","slug":"git","permalink":"http://leoyoung07.github.io/blog/tags/git/"},{"name":"server","slug":"server","permalink":"http://leoyoung07.github.io/blog/tags/server/"}]},{"title":"用JavaScript获取URL参数的方法","slug":"javascript-get-url-search-params","date":"2016-03-26T16:00:00.000Z","updated":"2017-02-08T05:30:13.482Z","comments":true,"path":"2016/03/27/javascript-get-url-search-params/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2016/03/27/javascript-get-url-search-params/","excerpt":"","text":"JavaScript中通过正则表达式获取URL参数的方法： 1234567function getQueryString(name) &#123; var reg = new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\", \"i\"); var r = location.search.substr(1).match(reg); if (r != null) return decodeURI(r[2]); return null;&#125; r[2]是分组2的内容，即([^&amp;]*)所匹配的内容（r[0]是整个正则表达式所匹配的内容） 正则表达式后边的“i”表示忽略大小写","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://leoyoung07.github.io/blog/categories/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://leoyoung07.github.io/blog/tags/javascript/"},{"name":"regex","slug":"regex","permalink":"http://leoyoung07.github.io/blog/tags/regex/"}]},{"title":"微信公众平台下通过网页授权获取用户信息的方法","slug":"wechat-auth-get-user-info","date":"2016-03-21T16:00:00.000Z","updated":"2017-02-08T05:29:46.773Z","comments":true,"path":"2016/03/22/wechat-auth-get-user-info/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2016/03/22/wechat-auth-get-user-info/","excerpt":"","text":"授权方式微信网页的授权方式分为两种： 以 snsapi_base 为 scope 发起的网页授权：用于获取用户的 openid ，为静默授权 以 snsapi_userinfo 为 scope 发起的网页授权：用于获取用户的基本信息，需要用户手动同意授权 下面以 snsapi_userinfo 的类型为例，说明网页授权的步骤： 获取code引导关注者打开以下页面： https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=STATE#wechat_redirect 其中 redirect_uri 为需要获取用户信息的页面，redirect_uri 需要进行 urlencode 处理。用户同意授权之后，redirect_uri 的页面就可以通过 GET 的方式从 url 中拿到 code，即： $code = $_GET[&quot;code&quot;]; 用code换取网页授权的access_token利用上一步获取的code即可换取网页授权access_token，方法如下： 12345678$api_url = \"https://api.weixin.qq.com/sns/oauth2/access_token?appid=&#123;$appid&#125;&amp;secret=&#123;$secret&#125;&amp;code=&#123;$code&#125;&amp;grant_type=authorization_code\";$response_info = self::get_info_from_api($api_url);if(isset($response_info[\"errcode\"]))&#123; exit(\"get access token failed: \".$response_info[\"errcode\"].\", \".$response_info[\"errmsg\"]);&#125;$access_token = $response_info[\"access_token\"]; 其中，get_info_from_api 的定义如下： 123456789101112public static function get_info_from_api($api_url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $api_url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); $result = curl_exec($ch); curl_close($ch); $response_info = json_decode($result, true); return $response_info;&#125; get_info_from_api 是利用PHP中的curl函数以 GET 方法从微信提供的 api 获取数据，返回的结果为关联数组的形式。 获取用户信息接下来，即可用 access_token 获取用户信息： 1234567$open_id = $response_info[\"openid\"];$api_url = \"https://api.weixin.qq.com/sns/userinfo?access_token=&#123;$access_token&#125;&amp;openid=&#123;$open_id&#125;&amp;lang=zh_CN\";$user_info = self::get_info_from_api($api_url);if(isset($user_info[\"errcode\"]))&#123; exit(\"get user info failed: \".$user_info[\"errcode\"].\", \".$user_info[\"errmsg\"]);&#125;","categories":[{"name":"WeChat","slug":"WeChat","permalink":"http://leoyoung07.github.io/blog/categories/WeChat/"}],"tags":[{"name":"php","slug":"php","permalink":"http://leoyoung07.github.io/blog/tags/php/"},{"name":"wechat","slug":"wechat","permalink":"http://leoyoung07.github.io/blog/tags/wechat/"}]},{"title":"将数字转换为EXCEL列名的方法","slug":"number-to-excel-letter","date":"2015-12-25T16:00:00.000Z","updated":"2017-02-08T05:39:50.350Z","comments":true,"path":"2015/12/26/number-to-excel-letter/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2015/12/26/number-to-excel-letter/","excerpt":"","text":"用递归函数将数字转换为EXCEL中的列名，直接上代码（PHP）： 12345678910111213141516171819202122232425//递归求解function R_NumToLetter($num)&#123; if($num == 0) &#123; return ''; &#125; $base = 26; $mod = (int)($num % $base); $num = (int)($num / $base); if($mod == 0) return R_NumToLetter($num - 1).NumToLetter($base); if($num == 0) return NumToLetter($mod); return R_NumToLetter($num).NumToLetter($mod);&#125;function NumToLetter($num)&#123; if($num == 0) return ''; $num = (int)$num - 1; $ord_A = ord('A'); $chr = chr($ord_A + $num); return $chr;&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"http://leoyoung07.github.io/blog/categories/PHP/"}],"tags":[{"name":"php","slug":"php","permalink":"http://leoyoung07.github.io/blog/tags/php/"},{"name":"convert","slug":"convert","permalink":"http://leoyoung07.github.io/blog/tags/convert/"}]},{"title":"微信公众平台带参数二维码配置工具的实现","slug":"wechat-qr-code-manage","date":"2015-12-08T16:00:00.000Z","updated":"2017-02-08T05:29:20.565Z","comments":true,"path":"2015/12/09/wechat-qr-code-manage/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2015/12/09/wechat-qr-code-manage/","excerpt":"","text":"配置带参数的二维码同样需要先获取Access Token，获取方法在 微信公众平台自定义菜单配置工具的实现 一文中有描述。 利用获取到的Access Token，可以创建二维码的Ticket。通过POST方法向服务器提交相关信息，JS代码如下： 123456789101112131415161718192021222324252627282930function getTicket()&#123; var url = \"qrcode_manage.php?access_token=\"+$(\"#accessToken\").val(); var qrcode_type = $(\"#qrType\").val(); var qrcode_scene_id = $(\"#qrSceneId\").val(); $.post(url, &#123; \"qrcode_type\":qrcode_type, \"qrcode_scene_id\":qrcode_scene_id &#125;, function (data,status) &#123; var result = eval(\"(\"+data+\")\"); $(\"#ticketInfo\").css(\"display\",\"block\"); if(typeof (result[\"errcode\"])!=\"undefined\") &#123; var errorInfo = \"错误代码：\"+result[\"errcode\"]+\";错误信息：\"+result[\"errmsg\"]; $(\"#ticketInfo\").html(errorInfo); $(\"#getQrcodeBtn\").attr(\"disabled\",\"disabled\"); &#125; else &#123; var successInfo = \"获取Ticket 成功，Ticket：\" + result[\"ticket\"]; successInfo += \"&lt;br&gt;url:\" + result[\"url\"]; $(\"#ticket\").val(result[\"ticket\"]); $(\"#ticketInfo\").html(successInfo); $(\"#getQrcodeBtn\").removeAttr(\"disabled\"); &#125; &#125; );&#125; 服务器端进行转发的PHP代码如下： 123456789101112131415161718192021222324252627$access_token = $_GET[\"access_token\"];$api_url = \"https://api.weixin.qq.com/cgi-bin/qrcode/create?access_token=&#123;$access_token&#125;\";$qrcode_type = $_POST[\"qrcode_type\"];$qrcode_scene_id = (int)$_POST[\"qrcode_scene_id\"];$qrcode_array = array();if($qrcode_type == \"QR_SCENE\")&#123; $qrcode_array[\"expire_seconds\"] = 604800; //七天 $qrcode_array[\"action_name\"] = \"QR_SCENE\";&#125;else&#123; $qrcode_array[\"action_name\"] = \"QR_LIMIT_SCENE\";&#125;$qrcode_array[\"action_info\"][\"scene\"][\"scene_id\"] = $qrcode_scene_id;$qrcode_json = json_encode($qrcode_array);$ch = curl_init();curl_setopt($ch,CURLOPT_URL,$api_url);curl_setopt($ch,CURLOPT_RETURNTRANSFER,1);curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);curl_setopt($ch, CURLOPT_POST, 1);curl_setopt($ch, CURLOPT_POSTFIELDS, $qrcode_json);$json_result = curl_exec($ch);curl_close($ch);echo $json_result; 之后，可以通过Ticket换取二维码，JS代码如下： 1234567function getQrcode()&#123; var ticket = $(\"#ticket\").val(); var date = new Date(); var url = \"qrcode_manage.php?ticket=\"+ticket+\"&amp;time=\"+date.getTime(); $(\"#qrcode\").attr(\"src\",\"qrcode_manage.php?ticket=\"+ticket+\"&amp;time=\"+date.getTime());&#125; 服务器端进行转发的PHP代码如下： 12345678910$ticket = $_GET[\"ticket\"];$api_url = \"https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=&#123;$ticket&#125;\";$ch = curl_init();curl_setopt($ch,CURLOPT_URL,$api_url);curl_setopt($ch,CURLOPT_RETURNTRANSFER,1);curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);$qrcode_result = curl_exec($ch);curl_close($ch);echo $qrcode_result; 实现效果可访问： http://leo07.sinaapp.com/qrcode_manage.html","categories":[{"name":"WeChat","slug":"WeChat","permalink":"http://leoyoung07.github.io/blog/categories/WeChat/"}],"tags":[{"name":"php","slug":"php","permalink":"http://leoyoung07.github.io/blog/tags/php/"},{"name":"curl","slug":"curl","permalink":"http://leoyoung07.github.io/blog/tags/curl/"},{"name":"wechat","slug":"wechat","permalink":"http://leoyoung07.github.io/blog/tags/wechat/"},{"name":"tools","slug":"tools","permalink":"http://leoyoung07.github.io/blog/tags/tools/"}]},{"title":"微信公众平台自定义菜单配置工具的实现","slug":"wechat-button-manage","date":"2015-12-08T16:00:00.000Z","updated":"2017-02-08T05:28:56.199Z","comments":true,"path":"2015/12/09/wechat-button-manage/","link":"","permalink":"http://leoyoung07.github.io/blog/blog/2015/12/09/wechat-button-manage/","excerpt":"","text":"由于JS脚本跨域访问的问题，无法通过jQuery的Ajax方法直接调用微信的API，故采用服务器端转发的方式与微信API交互。 配置自定义菜单须先获取Access Token，前端JS代码如下： 12345678910111213141516171819202122232425function getAccessToken()&#123; var appidParam = $(\"#appid\").val(); var secretParam = $(\"#secret\").val(); var date = new Date(); var url = \"get_access_token.php?appid=\"+appidParam+\"&amp;secret=\"+secretParam+\"&amp;time=\"+date.getTime(); $.get(url, function (data,status) &#123; var result = eval(\"(\"+data+\")\"); $(\"#info\").css(\"display\",\"block\"); if(typeof (result[\"errcode\"])!=\"undefined\") &#123; var errorInfo = \"错误代码：\"+result[\"errcode\"]+\";错误信息：\"+result[\"errmsg\"]; $(\"#info\").html(errorInfo); $(\"#changeBtn\").attr(\"disabled\",\"disabled\"); &#125; else &#123; var successInfo = \"获取Access Token 成功：\" + result[\"access_token\"]; $(\"#accessToken\").val(result[\"access_token\"]); $(\"#info\").html(successInfo); $(\"#changeBtn\").removeAttr(\"disabled\"); &#125; &#125;)&#125; 服务器端使用PHP的curl工具进行转发，代码如下 1234567891011$appid = $_GET[\"appid\"];$secret = $_GET[\"secret\"];$api_url = \"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&#123;$appid&#125;&amp;secret=&#123;$secret&#125;\";$ch = curl_init();curl_setopt($ch,CURLOPT_URL,$api_url);curl_setopt($ch,CURLOPT_RETURNTRANSFER,1);curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);$json_result = curl_exec($ch);curl_close($ch);echo $json_result; 利用获取到的 Access Token，下一步可以配置自定义菜单。目前还需要自己编写自定义菜单的JSON，以后有时间会加上可视化界面。通过POST方法向服务器提交JSON的JS代码如下： 12345678910111213141516function changeButton()&#123; var url = \"button_manage.php?access_token=\"+$(\"#accessToken\").val(); var button_json = $(\"#buttonBody\").val(); $.post(url,&#123;\"button_json\":button_json&#125;, function (data,status) &#123; var result = eval(\"(\"+data+\")\"); if(result[\"errcode\"] == 0) &#123; alert(\"配置成功\"); &#125; else &#123; alert(\"配置失败，错误代码：\"+result[\"errcode\"]+\"错误信息：\"+result[\"errmsg\"]); &#125; &#125;)&#125; 服务器端的PHP代码如下： 12345678910111213$access_token = $_GET[\"access_token\"];$api_url = \"https://api.weixin.qq.com/cgi-bin/menu/create?access_token=&#123;$access_token&#125;\";$button_json = $_POST[\"button_json\"];$ch = curl_init();curl_setopt($ch,CURLOPT_URL,$api_url);curl_setopt($ch,CURLOPT_RETURNTRANSFER,1);curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);curl_setopt($ch, CURLOPT_POST, 1);curl_setopt($ch, CURLOPT_POSTFIELDS, $button_json);$json_result = curl_exec($ch);curl_close($ch);echo $json_result; 实现效果可访问： http://leo07.sinaapp.com/button_manage.html","categories":[{"name":"WeChat","slug":"WeChat","permalink":"http://leoyoung07.github.io/blog/categories/WeChat/"}],"tags":[{"name":"php","slug":"php","permalink":"http://leoyoung07.github.io/blog/tags/php/"},{"name":"curl","slug":"curl","permalink":"http://leoyoung07.github.io/blog/tags/curl/"},{"name":"wechat","slug":"wechat","permalink":"http://leoyoung07.github.io/blog/tags/wechat/"},{"name":"tools","slug":"tools","permalink":"http://leoyoung07.github.io/blog/tags/tools/"}]}]}