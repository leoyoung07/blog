最近在阅读K&R的经典之作The C Programming Language（C程序设计语言）时遇到了一个看似简单的函数 `getchar()` ，书中对其的描述是：

> `getchar()` 函数从文本流中读出下一个输入字符，并将其作为结果值返回。

并给出一段用于文件复制的代码：

```c
#include <stdio.h>

main()
{
    int c;
    while ((c = getchar()) != EOF)
    {
        putchar(c);
    }
}
```

书中说该例子*就是把输入一次一个字符地复制到输出*。而我在Ubuntu下和Windows下运行程序时发现每次输入完回车后，程序才会将输入的内容整行输出，即：

```bash
abcdef
abcdef
```

在网上查到， `getchar()` 是**有缓冲区、有回显**的，用户输入的字符（包括回车）被放在键盘缓冲区中，当用户输入回车后 `getchar()` 函数从缓冲区中每次读入一个字符，后续的 `getchar()` 不会等待用户按键，而是直接从缓冲区读取字符，直到读完缓冲区中的字符。

[有人](http://blog.csdn.net/stars2009/article/details/3837488)这样解释书中的描述：

> 在大师编写C的时候，当时并没有所谓终端输入的概念，所有的输入实际上都是按照文件进行读取的，文件中一般都是以行为单位的。因此，只有遇到换行符，那么程序会认为输入结束，然后采取执行程序的其他部分。同时，输入是按照文件的方式存取的，那么要结束一个文件的输入就需用到EOF (Enf Of File). 这也就是为什么getchar结束输入退出时要用EOF的原因。

而C语言中的 `getch()` 函数是**无缓冲区、无回显**的。同时，在Windows下（换行符为 `\r\n` ）调试的过程中发现 `getchar()` 和 `getch()` 对于换行符的处理不同： `getchar()` 返回的的是 `\n` 而 `getch()` 接收到 `\r` 就返回了。对此也[有人](http://bbs.csdn.net/topics/360137572#post-370454446)这样解释：

> 因为getchar()是标准的C库函数，在UNIX系统里回车一律只用\n。
Windows里回车输入的其实是\r\n，但是C库会对其进行处理（读写文本文件时也会），统一转换为规范的\n。而getch()则是比较低级的，会越过这个处理，貌似没有经过输入流缓冲，而是直接调用键盘服务中断获得的，就是原始按键。

另外，程序中使用 `int c` 而不是 `char c` 的原因是

> EOF在函数库里一般定义为-1。因此，在这种情况下，getchar函数返回一个负值，把一个负值赋给一个char型的变量是不正确的。
